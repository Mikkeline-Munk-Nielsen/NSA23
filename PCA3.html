<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>PCA III</title>
    <meta charset="utf-8" />
    <meta name="author" content="v. Mikkeline Munk Nielsen" />
    <script src="libs/header-attrs-2.19/header-attrs.js"></script>
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# PCA III
]
.subtitle[
## Nyere statistiske analysestrategier F23
]
.author[
### v. Mikkeline Munk Nielsen
]

---


<div>
<style type="text/css">.xaringan-extra-logo {
width: 220px;
height: 256px;
z-index: 0;
background-image: url(https://designguide.ku.dk/download/co-branding/ku_co_uk_h.jpg);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
top:1em;right:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>

# Program for i dag

- Recap

- Forudsagte factor scores og videre analyser

- Masser af øvelser! Øvelse i at gennemføre PCA fra start til slut, så vi er godt forberedte på eksamen.

- Oplæg fra Asger omkring brug af PCA i forbindelse med hans BA projekt

- Oplæg: hvordan kunne en PCA se ud til eksamen?

---
# Recap

De sidste par gange har vi lært at...
--

- PCA er en statistisk metode, der man kan reducere ”mange variable” til ”få grundlæggende variable” som opsummerer den fælles variation i de ”mange variable”.

--

- Det gør metoden særdeles praktisk til at måle et svært observerbare/latente fænomener eller begreber, fx en grundholdning, tillid, personlighed.

--

- Kan hjælpe med at undersøge om et fænomen/begreb er en- eller flerdimensionelt


---
# Recap

.pull-left[
![](Maalemodel.png)
]

.pull-right[
- Helt konkret kan PCA altså hjælpe os med at lave skalaer, der måler nogle af de sociale fænomener, som er vanskelige at observere direkte! 

- Sagt på en anden måde kan vi nemlig observere disse fænomener indirekte ved at lave nye variable, der opsummerer det, som en række manifeste variable har tilfælles.
]

---
# PCA trin for trin


**1)** Udvælg manifeste variable, som relaterer sig til det fænomen, som I er interesserede i at undersøge (operationalisering)

--

**2)** Vurdér de manifeste variables samvariation - undersøg deres korrelationsmatrice og vurdér dens faktorabiliet. Korrelerer varaiblene nok til, at vi med rimelighed kan antage, at de måler det samme?

--

**3)** Kør en pca i R ved at bruge **`prcomp()`** - denne kommando dekomponerer korrelationsmatricen for jer og danner nye komponenter/variable

--

**4)** Beslut hvor mange komponenter, det er meningsfuldt at beholde (vi vil jo gerne nedbringe antallet af variable til nogle få, der opsummerer de gamle)

--

**5)** Fortolk indholdet i de komponenter I har beholdt ved at analysere på hver komponents factor loadings. Vi roterer altid factor loadings for at lette fortolkningen, så vi bedre kan skelne mellem komponenterne.

--

**6)** Udtræk jeres nye variable og brug dem i analyser, som I plejer (temaet i dag)

---
# PCA trin for trin

** Trin 1: Udvælg manifeste variable**

Operationaliseringen består i at vælge variable, der relaterer sig til det givne fænomen (her tillid). Disse er fra European Social survey:


**1** `parliament = Trust in parliament`, 

**2** `legal_system = Trust in the legal system` 

**3** `police = Trust in the police`

**4** `politicians = Trust in politicians`

**5** `parties = Trust in parties` 

.pull-right[
*Skala: 0 (no trust at all) - 10 (complete trust)*
]


---
# PCA trin for trin

**2) Vurdér de manifeste variables samvariation** 

Undersøg deres korrelationsmatrice og vurdér dens ***faktorabiliet***. Korrelerer varaiblene nok til, at vi med rimelighed kan antage, at de måler det samme?



Vi kan start med at undersøge korrelationsmatricen:

```
##              parliament legal_system    police politicians   parties
## parliament    1.0000000    0.5584236 0.3784972   0.7224152 0.6775825
## legal_system  0.5584236    1.0000000 0.5763997   0.4839359 0.4645301
## police        0.3784972    0.5763997 1.0000000   0.3742397 0.3602119
## politicians   0.7224152    0.4839359 0.3742397   1.0000000 0.8380581
## parties       0.6775825    0.4645301 0.3602119   0.8380581 1.0000000
```
---
# PCA trin for trin

**2) Vurdér de manifeste variables samvariation** 

*KMO-test*

```
## Kaiser-Meyer-Olkin factor adequacy
## Call: KMO(r = matrice)
## Overall MSA =  0.78
## MSA for each item = 
##   parliament legal_system       police  politicians      parties 
##         0.86         0.78         0.77         0.73         0.76
```
*Bartletts sfæriske test*

```
## $chisq
## [1] 4462.743
## 
## $p.value
## [1] 0
## 
## $df
## [1] 10
```
---
# PCA trin for trin

**3) Kør en pca i R ved at bruge** **`prcomp()`**

***1) egenvektorer*** 

```
## Standard deviations (1, .., p=5):
## [1] 1.7901072 0.9471709 0.6592398 0.5530609 0.3973792
## 
## Rotation (n x k) = (5 x 5):
##                     PC1        PC2        PC3        PC4         PC5
## parliament   -0.4757480 -0.1972727 -0.3697872  0.7620959  0.13120421
## legal_system -0.4217429  0.4622473 -0.6373561 -0.4491985 -0.02140483
## police       -0.3536159  0.6994720  0.5740129  0.2367686  0.01201909
## politicians  -0.4907882 -0.3524476  0.2112896 -0.1659430 -0.75015153
## parties      -0.4794576 -0.3659652  0.2879242 -0.3658333  0.64765385
```
***2) egenværdier (sdev^2)***

```r
(pca$eigen_values &lt;- pca$sdev^2)
```

```
## [1] 3.2044837 0.8971327 0.4345971 0.3058763 0.1579102
```
---
# PCA trin for trin

**4) Beslut hvor mange komponenter, det er meningsfuldt at beholde**

.pull-left[
**a)** Egenværdier &gt; 1 (Kaiser-Guttman kriteriet).

**b)** Cattell’s scree test (scree plot).

**c)** Parallel analysis (de facto standard i dag).
]

.pull-right[
.center[
![](Paran.png)
]
]

---
# PCA trin for trin

**5)** Fortolk indholdet i de komponenter I har beholdt med *factor loadings*


```r
(pca$factor_loadings &lt;- pca$rotation*t(matrix(rep(sqrt(pca$eigen_val),5),nrow=5,ncol=5))
) # Læg mærke til at jeg har specificeret matricens dimensioner (5x5) 
```

```
##                     PC1        PC2        PC3        PC4          PC5
## parliament   -0.8516399 -0.1868509 -0.2437785  0.4214855  0.052137823
## legal_system -0.7549651  0.4378272 -0.4201705 -0.2484341 -0.008505834
## police       -0.6330103  0.6625195  0.3784122  0.1309475  0.004776135
## politicians  -0.8785634 -0.3338281  0.1392905 -0.0917766 -0.298094603
## parties      -0.8582804 -0.3466316  0.1898111 -0.2023281  0.257364157
```





---
# PCA trin for trin

**5) Fortolk indholdet i de komponenter I har beholdt med factor loadings**

*For at lette fortolkningen og lettere kunne skelne mellem komponenter roterer vi factor loadings for at opnå "simple structure".* 


Vi bruger enten orthogonal (vinkelret) rotation:

```r
varimax(pca$factor_loadings[,1:2])
```

Eller oblique, som tillader komopnenter at korrelere

```r
Promax(pca$factor_loadings[,1:2])
```

---
# PCA trin for trin

.center[
&lt;img src="Rotation_viz_loadings.gif" width="85%" /&gt;
.center[.backgrnote[*af Jonas Strøyberg Jensen*]]
]

---
# PCA trin for trin

**6) Udtræk jeres nye variable og brug dem i analyser (temaet i dag)**




Når man har afsluttet sin PCA og nået frem til fortolkelige komponenter, så kan man arbejde videre med disse komponenter. På baggrund af en PCA kan man nemlig få komponenterne ud!


.pull-right[![](https://media.sproutsocial.com/uploads/2017/03/How-to-Build-a-Social-Media-Marketing-Funnel-That-Converts.png)]


--
.pull-left[
`\(\rightarrow\)` *forudsagte factor scores: hver observations placering på den/de nye skala(er)*
]

---
# Forudsagte factor scores

Der findes forskellige måder at genere factor scores som variable i sit datasæt. Vi bruger ”regressionsmetoden”, som er default i psych-pakken:


```r
# Predict values for each respondent on the (rotated) components with 
# factor.scores() from the psych-package:
pred &lt;- factor.scores(var, pca_obli$loadings)

# Add these predictions to your data:
data &lt;- bind_cols(data, pred$scores)
```


Her bruger man principperne i lineær regression til ”back out” vægtene for hver indikator.

---
# Forudsagte factor scores

Bemærk at psych standardiserer factor scores til en middelværdi på 0 og sd på 1. Det betyder, at de nye variables skalaer er i standardafvigelser! 

```r
describe(data$PC1)
```

```
##    vars    n mean sd median trimmed  mad   min  max range skew kurtosis   se
## X1    1 1593    0  1   -0.1   -0.05 0.97 -2.29 3.69  5.98 0.53     0.15 0.03
```
--

Det betyder, at en stigning på 1 = en stiging på 1 standardafvigelse.

--

*Det er ikke alle programmer/pakker der gør det, så det kan godt betale sig at være opmærksom på, at man nogle gange selv skal standardisere.*

--

**Nu er I klar til at bruge jeres nye variable i analyser!**


---
# Opsummering

Vi har været igennem følgende trin nu

**1)** Vurdere om korrelationsmatricen er faktorabel 

--

**2)** Køre en pca og bestemme, hvor mange komponenter vi beholder

--

**3)** Udregne og rotere factor loadings for at fortolke komponenterne

--

**4)** Udtrække forudsagte factor scores til videre analyse

---
# Program for resten af dagen:

Pause

--

- Arbejde videre med øvelse 1 "Børn er forskellige"
--

Pause

--

- Lave en PCA fra start til slut. Her kan i vælge imellem:

  + Tolerance, please!

  + Hvis din nabo var en...
  
  + Åbenhed
  

--

Pause(r)

--

- Oplæg fra Asger om hans brug af PCA i BA projekt!

--

- Hvordan kunne en PCA opgave se ud til eksamen?

---
# Hvordan kunne en PCA-opgave se ud?

.pull-left[
**LCA** gruppérer **personer** i nogle få grundlæggende *typer/klasser* 
&lt;break&gt;
![](https://www.umass.edu/family/sites/default/files/events/latent_class_analysis_image.png)

- Hvilke typer af...
- Hvor mange typer af...
- Hvad karakteriserer disse typer...
]

--
.pull-right[
**PCA** grupperer **variable** der måler det samme og omgrupperer dem til variable/skalaer, der opsummerer variationen på tværs af de gamle variable

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR41fy74OEaqmKaGalRK5yIihM9hFBfIUv27A&amp;usqp=CAU)
- Danner skalaer for svært observerbare fænomener
- Tænk kontinuert
- Er der nationale/sociale/demografiske forskelle i...

]


---
# Hvordan kunne en PCA-opgave se ud?

***Eksempel på spørgsmål:*** Er der nationale forskelle i institutionel tillid?

--

**1)** Operationalisering: Hvilke spørgsmål måler institutionel tillid?

--

**2** Argumenter for brugen af PCA: Tillid er svært at observere og måle direkte med en enkel variabel. PCA kan hjælpe os med at skabe nye variable, der opsummerer den fælles variation på tværs af vores udvalgte variable. Samtidig kan vi bruge metoden til at vurdere, om der er en eller flere dimensioner på spil og trække de relevante ud!

--

- Redegør for de overordnede principper i PCA i generelle termer. Orienter jer f.eks. i Kline 1994:kap.1+3

--

- I skal ikke udlede noget i hånden eller gå ind i matematikken. I skal bare redegøre for de grundlæggende principper i, at PCA kan udlede nye komponenter ved at dekomponere en korrelationsmatrice og beskrive overordnet, hvordan den går til værks


---
# Hvordan kunne en PCA-opgave se ud?

**3) Undersøg samvariationen mellem jeres variable - er korrelationsmatricen faktorabel?**

--

Redergør for og sammenlign de tre kriterier:

- Hver indikatorvariabel i en korrelationsmatrice skal have mindst en korrelation på over 0,3 (Hansen 2017)

- Kaiser-Meyer-Olkin test (KMO)

- Bartlett’s (sfæriske) test

--

*Men husk at bruge dem heuristisk - jeres teoretiske argumenter skal også informere jeres valg*

---
# Hvordan kunne en PCA-opgave se ud?

**4) Kør PCA og bestem antal komponenter**

--

Argumenter for jeres valg på baggrund af de tre kriterier (og beskriv logikken bag dem):

- Egenværdier &gt; 1 (Kaiser-Guttman kriteriet).

- Cattell’s scree test (scree plot).

- Parallel analysis (de facto standard i dag).

--

Hvis I er i tvivl om, hvor mange komponenter, som I skal beholde, så prøv at gå videre med et par forskellige. I skal vælge det antal, som giver de tydeligste komponenter, dvs. dem hvor I bedst kan skelne mellem dem, når I fortolker factor loadings. 

---
# Hvordan kunne en PCA-opgave se ud?

**5) Beskriv de komponenter, som I beholder**

--

- Udregn og roter factor loadings

- Argumenter først og fremmest for, hvilken rotationsmetode i foretrækker

- Undersøg orthogonal og oblique rotationer og argumenter for, hvilken en der er bedst i jeres tilfælde

- Navngiv jeres komponenter meningsfuldt (f.eks. PC1 "Tillid til politiske institutioner" og PC2 "Tillid til retssystemet")


---
# Hvordan kunne en PCA-opgave se ud?


**6) Udregn forudsagte factor scores og brug variablen(e) i videre analyser**

--

- Husk at factor scores er standardiserede til middelværdi 0 og standardafvigelse 1. Komponenternes skala er altså i standardafvigelser!

- Det er oplagt at køre regressionsanalyse med jeres nye komponenter og finde ud af, om der f.eks. er nationale/socioøkonomiske/demografiske forskelle

--

*No need to overdo it og køre fuld IV-estimation eller RD. En simpel multipel regressionsanalyse er rigeligt. Læringsmålet i faget er LCA og PCA, ikke andre fancy metoder!*

---
# Ekstra huskeregler til PCA

- PCA kan ikke håndtere missingværdier (laver listwise deletion). Dvs. der må ikke være missing på nogle af jeres manifeste variable.

- Jeres manifeste variable skal have samme skala. Forestil jer at sammenligne DKK og Euro - hvad ville PCA vægte højest? Det kan dog fikses ved at aktivere "scale-argumentet" i **`prcomp()`** så variablene standardiseres på forhånd. Hold jer til disse specifikationer:


```r
pca &lt;- prcomp(var, center = TRUE, scale = TRUE)
```

- Hvis jeres komponenter ender med at loade negativt så I får en skala, der f.eks. måler *mistillid* fremfor *tillid* kan I vende skalaen:


```r
data$PC1 &lt;-data$PC1*-1
```
... det svarer bare til at ændre fortegnet og har kun fortolkningsmæssig betydning. 


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLanguage": "r",
"highlightStyle": "zenburn",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"self_contained": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
